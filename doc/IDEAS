Parsing:
	- Use a parser combinator approach
	- Try a combined top down/bottom up approach.  As the lexer feeds tokens, a parser tree is searched to see if a parser already recognizes the incoming parser pattern.  If it can recognize it, it can consume the entire token stream whole-cloth, doing only small top-down parsing tasks on the token chunk.  This is sort of like tracing compilation, but for tokens
	
Reference Arithmetic:
	- The idea is that it's nice to be able to do stuff like (*ptr++) = 'c', but pointer arithmetic is dangerous
	- We could have an arithmetic semantic for references:
		MyObject ref = myObjects[2];			// Array has 4 elements	
		ref = &ref++;							// myObjects[3]
		ref = &ref++;							// undef (or exception, not sure)
		ref = &ref - 3;							// myObjects[0]
		
		MyObject bar = &ref;					// Same as MyObject bar = ref;
		
Automatic Meta generator:

	- meta(SomeClass) 		-> MetaClass
	- meta(deep SomeMethod) -> MetaMethod
	- meta(SomeProperty)	-> MetaProperty
	- meta(SomeField)		-> MetaField
		... (and so forth)
		
	typedef meta(SomeClass)	MetaSomeClass;
	
	- These classes would only be generated by the compiler only when the meta keyword is encountered
	
	- MetaClass has MetaFunctions, etc. so you can do:
		
		meta(SomeClass).Methods.DoSomething.Call(someClassInstance, ...);
	
	