Parsing:
	- Use a parser combinator approach
	- Try a combined top down/bottom up approach.  As the lexer feeds tokens, a parser tree is searched to see if a parser already recognizes the incoming parser pattern.  If it can recognize it, it can consume the entire token stream whole-cloth, doing only small top-down parsing tasks on the token chunk.  This is sort of like tracing compilation, but for tokens
	
Reference Arithmetic:
	- The idea is that it's nice to be able to do stuff like (*ptr++) = 'c', but pointer arithmetic is dangerous
	- We could have an arithmetic semantic for references:
		MyObject ref = myObjects[2];			// Array has 4 elements	
		ref = &ref++;							// myObjects[3]
		ref = &ref++;							// undef (or exception, not sure)
		ref = &ref - 3;							// myObjects[0]
		
		MyObject bar = &ref;					// Same as MyObject bar = ref;
		
Automatic Meta generator:

	- meta(SomeClass) 		-> MetaClass
	- meta(deep SomeMethod) -> MetaMethod
	- meta(SomeProperty)	-> MetaProperty
	- meta(SomeField)		-> MetaField
		... (and so forth)
		
	typedef meta(SomeClass)	MetaSomeClass;
	
	- These classes would only be generated by the compiler only when the meta keyword is encountered
	
	- MetaClass has MetaFunctions, etc. so you can do:
		
		meta(SomeClass).Methods.DoSomething.Call(someClassInstance, ...);

Exceptions:
	- setjmp/longjmp with some macros around them
	- Check out Greg's response: http://stackoverflow.com/questions/533968/c-finally-block-that-only-runs-on-exceptions/534242#534242
	
	- Support try/catch/finally/filter/fault
	- try/catch/finally as normal
	- filter: like catch, but can match on any expression and has access to the exception object
	- fault: like finally, but only runs when an exception (any exception!) is thrown.  Does not perturb the stack frame
	- resume: for when you don't care about the error and know you can continue