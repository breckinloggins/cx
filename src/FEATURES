Duck Typing:
	- Uses "as" specifier
	// In some class:
	public void ConfirmPrint(as IPrintable p)
	{
		if (!Alert("Are you sure you wish to print %s pages?", p.Pages))
			return;
			
		p.PrintAll();
	}
	
	// Somewhere else
	ConfirmPrint(myObj);	// myObj's class doesn't need to be an IPrintable, it just needs to support
							// the same properties and methods as an IPrintable

	- Why can't we move the "as" into a cast, instead of having to specify it per method?
		Because you want to let the method know that it can't possibly cast IPrintable to a real
		object that inherits IPrintable
		
Symbols:
	- Just like in Ruby, use ":symbol" where a string is expected:
		IPrintable myPrintableObject = printableObjectMap[:defaultViewObject];
	- Show up in intellisense in their enclosing scope
	- Kept in the _SYMBOLS table

Automatic Properties:
	- Like in C# 3.0, but with additional functionality
	
	// Normal automatic property
	public string FirstName { get; set; }
	
	// Use of "field" keyword to get to the backing field
	public string FirstName { get; set { FirePropertyChanged(); field = value; }}
	
	- This lets you incrementally build up a property.  With C#, it's all or nothing :-(
	
Special features for DSLs:
	- The last statement of a block is implicitly its return
	- Blocks can set their "this" pointer
	- If a block is the last argument to a method call, it can be placed AFTER the parenthesis
	- If a method only has one argument, the parenthesis can be left off
	- Named parameters
	
	// Allows such syntax as:
	HTML	{
		Head { Title "My Webpage"; }
		Body	{
			P "Hello and welcome to my webpage";
			BR;
			P "I hope you like what you see";
			
			Table (BackColor = :green, Padding = "3px")	{
				// More table stuff here
			}
		}
	}
	
Support for IDynamicObject as in C# 4.0:
	- Compiler doesn't complain about missing identifiers when method/property/field access is made to a
		descendent of IDynamicObject.  Makes hard calls when possible, passes all others to IDynamicObject.* methods